<?php

/**
 * @file
 * We will add the ability to request a node focused on a specific 
 * keyword or keyphrase. The node will have to be ready photo ready, content ready 
 * and editor ready before it can be published.
 *
 * We will add the ability for each node to have a "rating," which will be a
 * number from one to five.
 */
 
 
/**
* Implementation of hook_menu.
*/
/*
function prodqueue_menu() {
  $items['admin/settings/prodqueue'] = array(
    'title' => 'prodqueue',
    'description' => 'Enable or disable production queue for content types.',
    'page callback' => 'prodqueue_settings',
	//'callback arguments' => array('prodqueue_admin_settings'),
    'access callback' => TRUE,
    'expanded' => TRUE,
  );
	
	return $items;
}

function prodqueue_settings(){
	 return drupal_get_form('prodqueue_admin_settings');
}
*/
function prodqueue_menu() {
	$items['admin/settings/prodqueue'] = array(
		'title' => 'prodqueue',
		'description' => 'Enable or disable production queue for content types.',
		'page callback' => 'prodqueue_settings',
		//'callback arguments' => array('prodqueue_admin_settings'),
		'access callback' => TRUE,
		'expanded' => TRUE,
	);
	$items['prodqueue/callbacks/generate_pages'] = array(
		'type' => MENU_CALLBACK,
		'title' => 'Generate Page Requests',

		'page callback' => 'prodqueue_request_pages',
		'page arguments' => array(t('The menu entry for this page is of type MENU_CALLBACK, so it provides only a path but not a link in the menu links, but it is the same in every other way to the simplest example.')),
		'access callback' => TRUE,
	);
  
	$items['prodqueue/manage/content-checkout_list'] = array(
		//'type' => MENU_CALLBACK,
		'description' => t('List all content thay may be checked out'),
		'title' => 'Check Out Content',
		'page callback' => 'prodqueue_content_checkout_list',
		'access callback' => TRUE,
	);
  	
	return $items;
}

function prodqueue_content_checkout_list(){
	$list = '<table>';
	$result = db_query("SELECT node.nid AS nid,
   node.title AS node_title,
   node.type AS type,
   node.changed AS node_changed
 FROM {node} node 
 INNER JOIN {prodqueue} pq ON node.nid = pq.nid
 ORDER BY node_title ASC");
	while ($row = db_fetch_object($result)) {
		//$node = node_load($row->nid);
		$title = $row->node_title;
		$type = $row->type;
		$list .= '<tr><td>'.$title.'</td><td>'.$type.'</td></tr>'."\n";
  
		//drupal_set_message($update);
	}
	$list .= '</table>';
	
	return $list;
   
}



function prodqueue_request_pages() {
  return drupal_get_form('prodqueue_request_pages_form');
}

/*
 *
 */
 function prodqueue_request_pages_form($form_state){
 
	$form['requested_title'] = array (
		'#type' => 'textfield',
		'#title' => t('Title of Content You Want to Generate'),
		'#required' => TRUE,
	);
	$form['requested_nodetype'] = array(
		'#type' => 'select',
		'#title' => t('Node type of requested content'),
		//'#options' => node_get_types('names'),
		//'#options' => variable_get('prodqueue_nodetypes', array('story')),
		'#options' => get_prodqueue_nodes_array(),
		'#default_value' => variable_get('prodqueue_nodetypes', array('story')),
		//'#description' => t('Only listing node types that are managed by production queue.'),
		'#required' => TRUE,
	);
	$form['keyword1'] = array (
		'#type' => 'textfield',
		'#title' => t('Focus Keyword or Phrase 1'),
		'#required' => TRUE,
	);
	$form['keyword2'] = array (
		'#type' => 'textfield',
		'#title' => t('Focus Keyword or Phrase 2'),
		'#required' => TRUE,
	);
	$form['keyword3'] = array (
		'#type' => 'textfield',
		'#title' => t('Focus Keyword or Phrase 3'),
		'#required' => FALSE,
	);
	$form['keyword4'] = array (
		'#type' => 'textfield',
		'#title' => t('Focus Keyword or Phrase 4'),
		'#required' => FALSE,
	);
	 
	$form['submit'] = array (
		'#type' => 'submit',
		'#value' => t('Request it'),  
	);
	return $form;
 }
 
 /*
  * put the value (node type name) of the array in the key
  */
 function get_prodqueue_nodes_array(){
	$parray = variable_get('prodqueue_nodetypes', array('story'));
	foreach ($parray as $key => $value){
		$narray[$value] = $value;
	}
	return $narray;
 }

 function prodqueue_request_pages_form_validate ($form_id, &$form_state) {
	$req_node_type = $form_state['values']['requested_nodetype']; 
	$req_title = $form_state['values']['requested_title'];
	$keyword1 = $form_state['values']['keyword1'];
	$keyword2 = $form_state['values']['keyword2'];
	// check for duplicate titles in the nodes
	$existing_title = db_fetch_object(db_query("SELECT title FROM {node} where title = '%s'",$req_title));
	if(strtolower($existing_title->title) == strtolower($req_title)){
		form_set_error('requested_title',t('requested title exists'));
	}
	if (!$req_node_type != '') {
		form_set_error('requested_nodetype', t('Please select the node type that you would like to request'));
	}	
	if (!$req_title) {
		form_set_error('requested_title', t('Ooops! Please fill in the title for the requested content?'));
	}
	if (!$keyword1) {
		form_set_error('keyword1', t('Please fill in the keyword 1'));
	}
	if (!$keyword2) {
		form_set_error('keyword2', t('Please fill in the keyword 2'));
	}
}
 
/**
 * Once the form passes the validation (above) this runs
 * 
 * Docs @
 * http://api.drupal.org/api/file/developer/topics/forms_api.html/6
 * (under Submitting Forms)
 * 
 *
 */
function prodqueue_request_pages_form_submit ($form_id, &$form_state) {
	global $user;
	$req_node_type = $form_state['values']['requested_nodetype']; 
	$req_title = $form_state['values']['requested_title'];
	$keyword1 = $form_state['values']['keyword1'];
	$keyword2 = $form_state['values']['keyword2'];
	$keyword3 = $form_state['values']['keyword3'];
	$keyword4 = $form_state['values']['keyword4'];
  
  // Node ID must be a number that is not in the database.
  $max_nid_ob = db_fetch_object(db_query('SELECT MAX(nid) as max_nid FROM {node}'));
  //new_nid = $max_nid + mt_rand(1000, 1000000);
  $new_nid = $max_nid_ob->max_nid + 1;
  $title = $req_title;
/* 
 $node = array(
    'title' => $title, 
    //'body' => array(LANGUAGE_NONE => array(array('value' => $this->randomName(32)))), 
    'uid' => $user->uid, 
    'type' => $req_node_type, 
    'nid' => $new_nid, 
    'is_new' => TRUE,
	'is_request' => TRUE, //set so we can bypass the seo_keywords check at update
  );
  */

  $node = new stdClass();
 
//Main Node Fields
$node->name = $title;
$node->title = $title;
$node->body = "";
$node->type = $req_node_type;
$node->created = time();
$node->changed = $node->created;
$node->promote = 0; // Display on front page ? 1 : 0
$node->sticky = 0;  // Display top of page ? 1 : 0
$node->format = 2;  // 1:Filtered HTML, 2: Full HTML
$node->status = 0;   // Published ? 1 : 0
$node->language = 'en';
  
if ($node = node_submit($node)) {
	$node->is_request = TRUE;
    node_save($node);
    
	if(module_exists('seo_keywords')){
		db_query("INSERT INTO {seo_keywords} (nid, vid, timestamp, keyword1, keyword2, keyword3, keyword4) 
						VALUES (%d, %d, %d, '%s', '%s', '%s', '%s')", $node->nid, $node->vid, time(), $keyword1, $keyword2, $keyword3, $keyword4);
	}
	db_query("INSERT INTO {prodqueue} (nid, request_time) values(%d,%d)",$node->nid,time());
	
    //Enter Nodewords  
    //This is not required, but once you save the node, you can add meta tags via
    //the nodewords module
    
	//$nodewords['keywords']['value'] = $keywords;
    //$nodewords['description']['value'] = $description;
    //nodewords_save_tags(NODEWORDS_TYPE_NODE, $node->nid, $nodewords, TRUE);
 
    drupal_set_message(t("Node ".$node->title." added correctly"));
} else {
    drupal_set_message(t("Node ".$node->title." added incorrectly"), "error");
}
  
  // check_plain() makes sure there's nothing nasty going on in the text written by the user.
  $output .= check_plain($req_title);
  $output .= t(' the content <i>@title</i> was requested successfully', array('@title' => $title));

  
  drupal_set_message($output);
}
 
function prodqueue_settings() {
	 return drupal_get_form('prodqueue_admin_settings');
}
 
/*
 * Define the settings form 
 */
function prodqueue_admin_settings() {
	/*$form['prodqueue_nodetypes'] = array(
		'#type' => 'checkboxes',
		'#title' => t('prodqueue may be applied to these node types'),
		'#options' => node_get_types('names'),
		'#default_value' => variable_get('prodqueue_nodetypes', array('story')),
		'#description' => t('prodqueue will be available on these node types.'),
	);*/
	
	drupal_set_title(t('Production Queue Settings'));
    
    $types = node_get_types('names');
    
    // Build a cool settings table, allowing a content type to be checked, and default points and revisit values.
    
    foreach($types as $machine => $name) {
        $form['types'][$machine]['enabled'] = array('#type' => 'checkbox');
        $form['types'][$machine]['content_type'] = array('#value' => $name);
        $form['types'][$machine]['points'] = array('#type' => 'textfield', '#size' => 3, '#value' => 2.5);
        $form['types'][$machine]['revisit'] = array('#type' => 'textfield', '#size' => 3, '#value' => 365);
    }
    
    // Apply system_settings_form fields before theme, since theme is reset.
    $form = system_settings_form($form);
    
    $form['#theme'] = 'prodqueue_admin_form';
    $form['#tree'] = TRUE;
	return $form;
}

function prodqueue_theme() {
    return array(
        'prodqueue_admin_form' => array(
            'arguments' => array('form' => NULL),
        ),
    );
}


function theme_prodqueue_admin_form($form) {
    $output = t("<p>Settings to determine which " . l(t('Content Types'), 'admin/content/types') . " are managed by the Production Queue. You can also set the points to award the Author upon Publish, as well as default Revisit period.</p>");
    
    $rows = array();
    
    foreach(element_children($form['types']) as $key) {
        $row = array();
        $row[] = drupal_render($form['types'][$key]['enabled']);
        $row[] = drupal_render($form['types'][$key]['content_type']);
        $row[] = drupal_render($form['types'][$key]['points']);
        $row[] = drupal_render($form['types'][$key]['revisit']);
        $rows[] = $row;
    }
    
    $header = array('', t('Content Type'), t('Points'), t('Default Revisit Time (Days)'));
    
    $output .= theme('table', $header, $rows);
    
    return $output . drupal_render($form);
}
 
 
 /**
 * Implementation of hook_block().
 *
 * This hook both declares to Drupal what blocks are provided by the module, and
 * generates the contents of the blocks themselves.
 */
function prodqueue_block($op = 'list', $delta = '', $edit = array()) {
  // The $op parameter determines what piece of information is being requested.
  switch ($op) {
    case 'list':
      // If $op is "list", we just need to return a list of block descriptions.
      // This is used to provide a list of possible blocks to the administrator;
      // end users will not see these descriptions.
      $blocks['production-queue'] = array(
        'info'       => t('BIZX Production Queue'),
      );
      // A block can provide default settings. In this case we'll enable the
      // block and make it visible only on the 'node/*' pages.
     /* $blocks['empty'] = array(
        'info'       => t('BIZX Production Queue'),
        'status'     => TRUE,
        'weight'     => 0,
        'visibility' => 1,
        //'pages'      => 'node/*',
      );*/
      return $blocks;
    case 'configure':
      // If $op is "configure", we need to provide the administrator with a
      // configuration form. The $delta parameter tells us which block is being
      // configured. In this example, we'll allow the administrator to customize
      // the text of the first block.
      $form = array();
      if ($delta == 'production-queue') {
        // All we need to provide is a text field, Drupal will take care of
        // the other block configuration options and the save button.
        $form['block_example_string'] = array(
          '#type' => 'textfield',
          '#title' => t('Block contents'),
          '#size' => 60,
          '#description' => t('This string will appear in the example block.'),
          //'#default_value' => variable_get('block_example_string',  t('Some example content.')),
		  '#default_value' => t('Some example content.'),
        );
      }
      return $form;
    case 'save':
      // If $op is "save", we need to save settings from the configuration form.
      // Since the first block is the only one that allows configuration, we
      // need to check $delta to make sure we only save it.
      if ($delta == 'production-queue') {
        // Have Drupal save the string to the database.
        variable_set('block_example_string', $edit['block_example_string']);
      }
      return;
    case 'view':
      //  The $delta parameter tells us which block is being requested.
      switch ($delta) {
        case 'production-queue':
          $block['subject'] = t('Production Queue');
          $block['content'] = prodqueue_block_contents();
          break;
      }
      return $block;
  }
}

// custom function to generate the block content
function prodqueue_block_contents(){

      // Modules would typically perform some database queries to fetch the
      // content for their blocks. Here, we'll just use the variable set in the
      // block configuration or, if none has set, a default value.
	  $prodqueue_links = t('
	  <ul>
	  <li><a href="!genlink">Generate Pages</a></li>
	  <li><a href="#">Photo Queue</a></li>
	  <li><a href="#">Content Queue</a></li>
	  <li><a href="#">Editor Queue</a></li>
	  <li><a href="#">Rejected</a></li>
	  <li><a href="#">Revisit</a></li>
	  <li><a href="!settings">Settings</a></li>
	  </ul>
	  <h3>Edit Queue</h3>
	  <ul>
	  <li><a href="!checkout">Check Out</a></li>
	  <li><a href="">Edit and Submit</a></li>
	  </ul>',
	  array('!genlink' => url("prodqueue/callbacks/generate_pages", array('absolute' => TRUE)),
			'!settings' => url("admin/settings/prodqueue", array('absolute' => TRUE)),
			'!checkout' => url("prodqueue/manage/content-checkout_list", array('absolute' => TRUE))
			)
	  );
	  return $prodqueue_links;
      //return variable_get('block_example_string',  t('A default value.'));

}

/**
* Implementation of hook_nodeapi().
*/
function prodqueue_nodeapi(&$node, $op, $teaser, $page) {
    switch ($op) {
		// Delete is called when the node is being deleted, it gives us a chance
		// to delete the seo keywords and all revisions as well.
		case 'delete':
			db_query('DELETE FROM {prodqueue} WHERE nid = %d', $node->nid);
			break;
	}
}